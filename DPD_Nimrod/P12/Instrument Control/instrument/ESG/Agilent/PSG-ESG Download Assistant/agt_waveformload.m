function [status, status_description] = agt_waveformload(connection, IQData, ArbFileName, sample_rate, play_flag, normscale_flag, markers)
% PSG/ESG Download Assistant, Version 1.2
% Copyright (C) 2003 Agilent Technologies, Inc.
%
% function [status, status_description] = agt_waveformload(connection, IQData, ArbFileName, sample_rate, play_flag, 
%                                                          normscale_flag, markers)
% 
% The function downloads, and optionally plays, IQ data on the signal generator
%
% Output:        
%   status              integer     status of download. 0:download succeeded, -1:download failed
%   status_description  string      if status is < 0, status_description contains an error message.
%
% Input:
%   connection     A structure generated by the agt_newconnection function.
%   IQData         IQ data array. This should be a 1D complex array. I+jQ.
%   ArbFileName    Optional parameter.  The Arb file name (string).  If nothing is specified
%                  the default is 'Untitled'
%   sample_rate    Optional parameter.  If nothing is specified, the default sample rate is what 
%                  the signal generator is currently set to.
%   play_flag      Optional parameter.  This parameter either plays or does not play a 
%                  waveform on the signal generator.  If a waveform shouldn't be played
%                  specify 'no_play'.  Default is 'play'.
%   normscale_flag Optional parameter.  Specify 'normscale' if the data is to be normalized to +/- 1 and
%                  scaled at 70%.  Specify 'no_normscale' if the data will not be normalized and scaled
%                  within this function.
%   Markers        Optional parameter.  Marker is a 2D array with the size of nMarker x nIQDataLenth. Each 
%                  marker can be either 0 or 1. Default is that no markers will be set.
if(nargin) < 2
    error('at least three input parameter is needed');
end

%if (nargin < 7) markers   = zeros(2,length(IQData)); end;
if (nargin < 7) markers = []; end;
if (nargin < 6) normscale_flag = 'normscale'; end;
if (nargin < 5) play_flag = 'play'; end;
if (nargin < 4) sample_rate = 0; end;
if (nargin < 3) ArbFileName = 'Untitled'; end;

if (~ischar(ArbFileName))
    error('ArbFileName should be a string');
end

if (strcmpi( normscale_flag, 'no_normscale' ) )
    maxval = max_huge(IQData);
    if ( maxval > 1)
        error('IQData must be in the range [ -1:1 ]' );
    end
end

% make sure IQ data is a 1xN array.
[m,n] = size(IQData);
if (m ~= 1)
    error('IQData should be an 1xN complex array ');
end
IQDataLen = length(IQData);

%if (isempty(markers))
%    markers   = zeros(2,length(IQData));
%end

if (~isempty(markers))
    markerDim = size(markers);
    if (length(markerDim) ~= 2) 
        error('markers should be a 2 D array');
    end
    
    [rowMarker,colMarker] = size(markers);
    if (rowMarker == IQDataLen) 
        markers = markers';
        [rowMarker,colMarker] = size(markers);
    end
    
    if (colMarker ~= IQDataLen) 
        error('markers should have the same length as IQData');
    end
end

if (~ischar(play_flag))
    error('play_flag should be a string');    
end

[status, status_description] = agt_sendcommand(connection,':source:rad:arb:state off');
if (status < 0)
    return;
end

if (isempty(markers))
    [status,status_description] = agt_sgIOmx( int32(4), connection, IQData, ArbFileName, normscale_flag);
else
    [status,status_description] = agt_sgIOmx( int32(4), connection, IQData, ArbFileName, normscale_flag, markers);    
end

if (status < 0)
    return;
end

if ( sample_rate ~= 0 )
    [status, status_description] = agt_sendcommand(connection, [ ':SOURce:RADio:ARB:CLOCk:SRATe ' num2str(sample_rate) ] );
    if (status < 0)
        return;
    end
end

playcommand = [':source:rad:arb:wav "arbi:' ArbFileName '"'];

if ( strcmpi(play_flag, 'play') )
    [status, status_description] = agt_sendcommand(connection,playcommand);
    if (status < 0)
        return;
    end
    [status, status_description] = agt_sendcommand(connection,':source:rad:arb:state on');
    if (status < 0)
        return;
    end
end


function maxval = max_huge(iqdata)

blocksize = 1000000;
datasize = length(iqdata);
if (datasize < blocksize)
    maxval = max( abs([ real( iqdata ) imag( iqdata )]));
    return;
end

nItr =    floor(datasize / blocksize);
nRemain = rem(datasize , blocksize);

maxval = 0;
start = 1;
for i = 1:nItr
    stop = start + blocksize - 1;
    tempmax = max( abs( [ real( iqdata(start:stop) ) imag( iqdata (start:stop)) ] ) );
    if (tempmax > maxval)
        maxval = tempmax;
    end
    start = stop + 1;
end
if (nRemain > 0)
    stop = start + nRemain - 1;
    tempmax = max( abs([ real( iqdata(start:stop) ) imag( iqdata (start:stop)) ] ) );
    if (tempmax > maxval)
        maxval = tempmax;
    end
end

maxval;